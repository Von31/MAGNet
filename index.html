<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAGNeT - Multi-Agent Diffusion Forcing Transformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            font-size: 1.0625rem; /* 17px base */
            background: #fafafa;
            color: #1f2937;
            line-height: 1.7;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 260px;
            background: #fafafa;
            padding: 2.5rem 0;
            position: fixed;
            height: 100vh;
            top: 0;
            left: 0;
            overflow-y: auto;
            z-index: 100;
            border-right: 1px solid #e5e7eb;
        }

        .sidebar::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 2px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        .logo {
            padding: 0.5rem 1rem 2rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .logo-image {
            width: 100%;
            margin: 0 auto 1rem;
            background: transparent;
            border-radius: 8px;
            display: block;
            border: none;
            overflow: hidden;
        }

        .logo-image img {
            width: 100%;
            height: auto;
            display: block;
            object-fit: contain;
            margin: 0;
            padding: 0.5rem;
        }

        .logo-placeholder {
            color: #9ca3af;
            font-size: 0.875rem;
            text-align: center;
        }

        .logo h1 {
            font-size: 1.375rem;
            color: #111827;
            font-weight: 600;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .logo p {
            font-size: 1rem;
            color: #6b7280;
            margin-bottom: 1.25rem;
            line-height: 1.6;
        }

        .logo-links {
            display: flex;
            gap: 2.5rem;
            justify-content: center;
            align-items: flex-start;
            padding: 1.5rem 0;
            margin-top: 1rem;
        }

        .logo-link-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

        .logo-link {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: #ffffff;
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #4b5563;
            text-decoration: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .logo-link:hover {
            background: #1f2937;
            color: #ffffff;
            border-color: #1f2937;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .logo-link svg {
            width: 28px;
            height: 28px;
        }

        .logo-link-label {
            font-size: 0.875rem;
            color: #4b5563;
            text-align: center;
            font-weight: 600;
        }

        .nav-section {
            padding: 0 1.5rem;
            margin-bottom: 2rem;
        }

        .nav-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9ca3af;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .nav-item {
            padding: 0.75rem 1rem;
            margin: 0.125rem 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.875rem;
            color: #6b7280;
            text-decoration: none;
            font-size: 1rem;
            position: relative;
        }

        .nav-item:hover {
            background: #ffffff;
            color: #111827;
        }

        .nav-item.active {
            background: #ffffff;
            color: #111827;
            font-weight: 500;
        }

        .nav-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 60%;
            background: #111827;
            border-radius: 0 2px 2px 0;
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .nav-item:hover .nav-icon {
            stroke: #4f46e5;
        }

        .nav-item.active .nav-icon {
            stroke: #4f46e5;
        }

        .nav-item img {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            object-fit: contain;
        }

        /* Main Content */
        .main-content {
            margin-left: 260px;
            flex: 1;
            padding: 3rem;
            width: calc(100% - 260px);
            max-width: none;
        }

        .hero-section {
            margin-bottom: 4rem;
            text-align: center;
        }

        .hero-section h2 {
            font-size: 3.5rem; /* 56px */
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #1f2937;
        }

        .hero-description {
            font-size: 1.375rem; /* 22px */
            color: #4b5563;
            max-width: 100%;
            margin: 0 auto;
            line-height: 1.8;
        }

        /* Section Styles */
        .section {
            margin-bottom: 5rem;
        }

        .section-header {
            margin-bottom: 2.5rem;
        }

        .section-header h3 {
            font-size: 2.25rem; /* 36px */
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }

        .section-header p {
            color: #6b7280;
            font-size: 1.125rem; /* 18px */
        }

        /* Teaser Video Section */
        .teaser-video {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        .video-player {
            width: 100%;
            aspect-ratio: 16/9;
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .video-player video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .video-placeholder {
            text-align: center;
            color: #6b7280;
        }

        .video-placeholder svg {
            width: 80px;
            height: 80px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Capability Grid */
        .capability-grid {
            display: grid;
            grid-template-columns:1fr;
            gap: 2.5rem;
        }

        .capability-card {
            background: #ffffff;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .capability-card:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            transform: translateY(-4px);
        }

        /* Video Gallery Styles */
        .video-gallery-section {
            width: 100%;
            margin-bottom: 2rem;
        }

        .video-gallery-container {
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        .video-gallery {
            display: flex;
            gap: 1.5rem;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            padding: 1rem 1.5rem;
            scrollbar-width: none;
            -ms-overflow-style: none;
            cursor: grab;
        }

        .video-gallery:active {
            cursor: grabbing;
        }

        .video-gallery::-webkit-scrollbar {
            display: none;
        }

        .gallery-video {
            flex: 0 0 auto;
            width: calc((100vw - 360px - 48px) / 3);
            max-width: 500px;
            min-width: 300px;
            height: auto;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            background: #ffffff;
            scroll-snap-align: center;
            object-fit: contain;
            display: block;
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            opacity: 0.7;
        }

        .gallery-video.center {
            transform: scale(1.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            opacity: 1;
            z-index: 10;
        }

        .gallery-caption-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-top: 1rem;
            padding: 0 0.5rem;
        }

        .gallery-nav-controls {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .gallery-nav {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #4b5563;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .gallery-nav:hover:not(:disabled) {
            background: #1f2937;
            border-color: #1f2937;
            color: #ffffff;
        }

        .gallery-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .gallery-caption {
            flex: 1;
            color: #6b7280;
            font-size: 1.0625rem; /* 17px */
            line-height: 1.7;
            margin: 0;
        }

        .gallery-caption b {
            color: #1f2937;
            font-weight: 600;
        }

        .capability-info {
            padding: 1.5rem;
        }

        .capability-title {
            font-size: 1.5rem; /* 24px */
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1f2937;
        }

        .capability-description {
            font-size: 1.0625rem; /* 17px */
            color: #6b7280;
            margin-bottom: 1rem;
            line-height: 1.7;
        }

        /* Video Navigation */
        .video-navigation {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .video-nav-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #4b5563;
            flex-shrink: 0;
        }

        .video-nav-btn:hover:not(:disabled) {
            background: #1f2937;
            border-color: #1f2937;
            color: #ffffff;
        }

        .video-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .video-counter {
            flex: 1;
            text-align: center;
            font-size: 1rem;
            color: #6b7280;
            font-weight: 500;
        }

        .video-counter .current {
            color: #1f2937;
            font-weight: 600;
        }

        /* Comparison Section */
        .comparison-section {
            background: #ffffff;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e5e7eb;
            margin-bottom: 3rem;
        }

        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .comparison-method-title {
            font-size: 1.5rem; /* 24px */
            font-weight: 600;
            color: #1f2937;
        }

        .comparison-navigation {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .comparison-nav-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #4b5563;
        }

        .comparison-nav-btn:hover:not(:disabled) {
            background: #1f2937;
            border-color: #1f2937;
            color: #ffffff;
        }

        .comparison-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .comparison-counter {
            font-size: 1rem;
            color: #6b7280;
            font-weight: 500;
        }

        .comparison-counter .current {
            color: #1f2937;
            font-weight: 600;
        }

        .comparison-videos {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .comparison-side {
            display: flex;
            flex-direction: column;
        }

        .comparison-label {
            font-size: 1.0625rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #4b5563;
            text-align: center;
        }

        .comparison-label.ours {
            color: #1f2937;
        }

        .comparison-video {
            width: 100%;
            height: 280px;
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            overflow: hidden;
        }

        .comparison-video video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out;
        }

        .comparison-video video.swipe-out-left {
            transform: translateX(-100%);
            opacity: 0;
        }

        .comparison-video video.swipe-out-right {
            transform: translateX(100%);
            opacity: 0;
        }

        .comparison-video video.swipe-in-left {
            animation: swipeInLeft 0.4s ease-in-out;
        }

        .comparison-video video.swipe-in-right {
            animation: swipeInRight 0.4s ease-in-out;
        }


        /* ========================================
           DFoT Visualization Styles (Light Theme)
           ======================================== */
        .dfot-container {
            background: #ffffff;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e5e7eb;
        }

        .dfot-wrapper {
            max-width: 100%;
        }

        .dfot-header {
            margin-bottom: 24px;
        }

        .dfot-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .dfot-subtitle {
            font-size: 1.0625rem; /* 17px */
            color: #6b7280;
        }

        .dfot-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .dfot-tab {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            background: #f9fafb;
            color: #6b7280;
            transition: all 0.2s;
        }

        .dfot-tab.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }

        .dfot-tab:hover:not(.active) {
            background: #f3f4f6;
            border-color: #d1d5db;
        }

        .dfot-description {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 1.25rem 1.5rem;
            margin-bottom: 1.5rem;
        }

        .dfot-description-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dfot-description-title .icon {
            width: 20px;
            height: 20px;
            color: #6366f1;
        }

        .dfot-description-text {
            font-size: 0.9375rem;
            color: #4b5563;
            line-height: 1.7;
            margin: 0;
        }

        .dfot-description-formula {
            display: inline-block;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 0.375rem 0.75rem;
            font-family: 'Cambria Math', 'Times New Roman', serif;
            font-style: italic;
            color: #1f2937;
            margin: 0.5rem 0;
            font-size: 0.9375rem;
        }

        .dfot-description-highlight {
            color: #4f46e5;
            font-weight: 500;
        }

        .dfot-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .dfot-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dfot-btn-play {
            background: #059669;
            color: white;
            border-color: #059669;
        }

        .dfot-btn-play.paused {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .dfot-btn-reset {
            background: #f3f4f6;
            color: #374151;
        }

        .dfot-btn:hover {
            opacity: 0.9;
        }

        .dfot-speed {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dfot-speed label {
            color: #6b7280;
            font-size: 14px;
        }

        .dfot-speed input {
            width: 100px;
            accent-color: #1f2937;
        }

        .dfot-speed span {
            color: #6b7280;
            font-size: 14px;
            width: 32px;
        }

        .dfot-frame {
            color: #9ca3af;
            font-size: 14px;
            margin-left: auto;
        }

        .dfot-timeline {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 24px;
        }

        .dfot-timeline label {
            color: #6b7280;
            font-size: 14px;
        }

        .dfot-timeline input {
            flex: 1;
            height: 8px;
            cursor: pointer;
            accent-color: #1f2937;
        }

        .dfot-viz {
            background: #1e293b;
            border-radius: 10px;
            padding: 18px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .dfot-main {
            display: flex;
            justify-content: center;
        }

        .dfot-yaxis-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            width: 80px;
        }

        .dfot-yaxis-label span {
            color: #94a3b8;
            font-size: 14px;
            font-weight: 500;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }

        .dfot-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .dfot-xaxis-title {
            color: #94a3b8;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 8px;
        }

        .dfot-xaxis-labels {
            display: flex;
            justify-content: center;
            margin-bottom: 6px;
            margin-left: 36px;
        }

        .dfot-xaxis-group {
            display: flex;
            margin-right: 4px;
        }

        .dfot-xaxis-label {
            color: #94a3b8;
            font-size: 11px;
            text-align: center;
            width: 40px;
        }

        .dfot-xaxis-label:last-child {
            margin-left: 4px;
        }

        .dfot-grid {
            display: flex;
            justify-content: center;
        }

        .dfot-yaxis-numbers {
            display: flex;
            flex-direction: column;
            margin-right: 6px;
        }

        .dfot-yaxis-number {
            height: 44px;
            width: 36px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            color: #94a3b8;
            font-size: 12px;
        }

        .dfot-yaxis-number.active {
            color: #facc15;
            font-weight: bold;
        }

        .dfot-yaxis-number .arrow {
            color: #facc15;
            margin-right: 4px;
            animation: dfot-pulse 1s infinite;
        }

        @keyframes dfot-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .dfot-rows {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .dfot-row {
            display: flex;
            margin-bottom: 4px;
            padding: 2px;
            margin-left: -2px;
            border-radius: 5px;
            border: 2px solid transparent;
            transition: all 0.15s ease;
        }

        .dfot-row.active {
            background: rgba(250, 204, 21, 0.15);
            border-color: rgba(250, 204, 21, 0.8);
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.4), inset 0 0 15px rgba(250, 204, 21, 0.1);
        }

        .dfot-time-group {
            display: flex;
            margin-right: 4px;
        }

        /* Agentic sampling column wrappers - Red and Blue */
        .dfot-agent-col-wrapper {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .dfot-agent-col-wrapper.agent-a-wrapper {
            border: 2px solid hsl(0, 70%, 50%);
            border-radius: 6px;
            padding: 3px;
            background: hsla(0, 70%, 50%, 0.1);
        }

        .dfot-agent-col-wrapper.agent-b-wrapper {
            border: 2px solid hsl(210, 70%, 50%);
            border-radius: 6px;
            padding: 3px;
            margin-left: 3px;
            background: hsla(210, 70%, 50%, 0.1);
        }

        .dfot-block.active-row {
            outline: 3px solid rgba(250, 204, 21, 0.9);
            outline-offset: -1px;
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.6);
        }

        .dfot-block {
            width: 40px;
            height: 40px;
            border-radius: 5px;
            border: 2px solid;
            position: relative;
            overflow: hidden;
        }

        .dfot-time-group > .dfot-block:last-child {
            margin-left: 4px;
        }

        .dfot-block canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }

        .dfot-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-top: 18px;
            padding-top: 14px;
            border-top: 1px solid #334155;
            flex-wrap: wrap;
            width: 100%;
        }

        .dfot-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dfot-legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        .dfot-legend-text {
            color: #94a3b8;
            font-size: 11px;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .sidebar {
                width: 240px;
            }

            .main-content {
                margin-left: 240px;
                width: calc(100% - 240px);
                padding: 2rem;
            }
            
            .gallery-video {
                width: calc((100vw - 260px - 48px) / 3);
                max-width: 400px;
            }

            .capability-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: relative;
                height: auto;
                border-radius: 0;
                top: 0;
            }

            .main-content {
                margin-left: 0;
                width: 100%;
                padding: 2rem 1.5rem;
            }
            
            .teaser-video {
                max-width: 100%;
            }

            .hero-section h2 {
                font-size: 2.5rem;
            }

            .capability-grid,
            .comparison-grid {
                grid-template-columns: 1fr;
            }

            .gallery-video {
                width: calc((100vw - 3rem) / 3);
                max-width: 100%;
                min-width: 200px;
                height: auto;
            }
            
            .video-gallery {
                padding: 1rem 0.5rem;
            }

            .gallery-caption-container {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
            }

            .gallery-nav-controls {
                align-self: center;
            }

            .dfot-viz {
                padding: 16px;
                overflow-x: auto;
            }

            .dfot-tabs {
                gap: 6px;
            }

            .dfot-tab {
                padding: 8px 12px;
                font-size: 12px;
            }

            .method-sub-tabs {
                gap: 4px;
                margin-bottom: 1.5rem;
            }

            .method-sub-tab {
                padding: 10px 16px;
                font-size: 14px;
            }
        }

        /* Play Icon */
        .play-icon-large {
            width: 80px;
            height: 80px;
            background: rgba(31, 41, 55, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            z-index: 1;
            pointer-events: none;
        }

        .play-icon-large:hover {
            background: rgba(31, 41, 55, 1);
            transform: scale(1.1);
        }

        .video-player video {
            position: relative;
            z-index: 2;
        }

        .video-player:has(video[controls]) .play-icon-large,
        .capability-video:has(video) .play-icon-large {
            display: none;
        }

        .play-triangle {
            width: 0;
            height: 0;
            border-left: 25px solid white;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            margin-left: 6px;
        }

        .subsection-title {
            font-size: 1.75rem;
            margin: 3rem 0 1.5rem;
            color: #1f2937;
            font-weight: 600;
        }

        /* Method Sub-tabs */
        .method-sub-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 2rem;
            border-bottom: 2px solid #e5e7eb;
        }

        .method-sub-tab {
            padding: 12px 24px;
            border-radius: 8px 8px 0 0;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            background: transparent;
            color: #6b7280;
            transition: all 0.2s;
            position: relative;
            bottom: -2px;
        }

        .method-sub-tab.active {
            color: #1f2937;
            border-bottom-color: #1f2937;
            background: transparent;
        }

        .method-sub-tab:hover:not(.active) {
            color: #1f2937;
            background: rgba(0, 0, 0, 0.03);
        }

        .method-sub-tab-content {
            display: none;
        }

        .method-sub-tab-content.active {
            display: block;
        }

        /* MAGNeT Pipeline Visualization Styles */
        .magnet-viz-container {
            max-width: 100%;
            margin: 2rem auto 0;
            padding: 0;
        }

        .magnet-viz-header {
            text-align: center;
            margin-bottom: 12px;
        }

        .magnet-viz-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 4px;
            color: #1e293b;
        }

        .magnet-main-viz {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
        }

        .magnet-pipeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .magnet-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            flex-shrink: 1;
            min-width: 0;
        }

        .magnet-stage-label {
            font-size: 11px;
            color: #1e293b;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            text-align: center;
            margin-bottom: 2px;
            white-space: nowrap;
        }

        .magnet-video-placeholder {
            width: 50px;
            height: 60px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(59, 130, 246, 0.1));
            border-radius: 4px;
            border: 2px dashed #64748b;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            position: relative;
        }

        .magnet-video-placeholder-icon {
            font-size: 18px;
            opacity: 0.8;
        }

        .magnet-video-placeholder-text {
            font-size: 6px;
            color: #334155;
            text-align: center;
            padding: 0 3px;
            font-weight: 500;
        }

        .magnet-video-box {
            width: 110px;
            height: 110px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #64748b;
            background: #1e293b;
        }

        .magnet-video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .magnet-arrow {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .magnet-arrow-line {
            width: 16px;
            height: 3px;
            background: linear-gradient(90deg, #94a3b8, #64748b);
        }

        .magnet-arrow-head {
            width: 0;
            height: 0;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 7px solid #64748b;
        }

        .magnet-vqvae-encoder-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .magnet-encoder-with-condition {
            display: flex;
            align-items: center;
            position: relative;
        }

        .magnet-vqvae-input-simple {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            margin-right: 6px;
        }

        .magnet-input-title {
            font-size: 11px;
            font-weight: 700;
            color: #334155;
        }

        .magnet-decoder-output-simple {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            margin-left: 6px;
        }

        .magnet-output-title {
            font-size: 11px;
            font-weight: 700;
            color: #334155;
        }

        .magnet-condition-simple {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .magnet-condition-title {
            font-size: 11px;
            font-weight: 700;
            color: #334155;
        }

        .magnet-condition-blocks-row {
            display: flex;
            gap: 3px;
        }

        .magnet-vqvae-encoder {
            position: relative;
            width: 75px;
            height: 100px;
        }

        .magnet-encoder-shape {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .magnet-encoder-shape svg {
            width: 100%;
            height: 100%;
        }

        .magnet-encoder-content {
            position: absolute;
            top: 50%;
            left: 45%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1;
        }

        .magnet-encoder-title {
            font-size: 11px;
            font-weight: 700;
            color: #d97706;
            margin-bottom: 2px;
        }

        .magnet-encoder-subtitle {
            font-size: 8px;
            color: #475569;
        }

        .magnet-encoder-layers-inside {
            display: flex;
            flex-direction: column;
            gap: 3px;
            margin-top: 8px;
            width: 42px;
        }

        .magnet-encoder-layer-bar {
            height: 4px;
            background: rgba(245, 158, 11, 0.3);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .magnet-encoder-layer-bar::after {
            content: '';
            position: absolute;
            left: -100%;
            top: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(245, 158, 11, 0.7), transparent);
            animation: magnetEncoderSweep 1.2s ease-in-out infinite;
        }

        .magnet-encoder-layer-bar:nth-child(2)::after { animation-delay: 0.15s; }
        .magnet-encoder-layer-bar:nth-child(3)::after { animation-delay: 0.3s; }

        @keyframes magnetEncoderSweep {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .magnet-condition-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 8px;
        }

        .magnet-condition-arrow-up {
            width: 3px;
            height: 12px;
            background: linear-gradient(to top, #22c55e 50%, transparent 50%);
            background-size: 3px 8px;
            animation: magnetFlowUp 0.5s linear infinite;
            position: relative;
        }

        .magnet-condition-arrow-up::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 6px solid #22c55e;
        }

        @keyframes magnetFlowUp {
            0% { background-position: 0 20px; }
            100% { background-position: 0 0; }
        }

        .magnet-input-stage {
            gap: 8px !important;
        }

        .magnet-motion-repr-rotated {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .magnet-repr-label {
            font-size: 8px;
            color: #64748b;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .magnet-motion-repr-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .magnet-agent-repr-box {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            background: #ffffff;
            border-radius: 4px;
            border: 2px solid;
        }

        .magnet-agent-a-box {
            border-color: hsl(0, 70%, 55%);
            background: hsla(0, 70%, 95%, 0.5);
        }

        .magnet-agent-b-box {
            border-color: hsl(210, 70%, 55%);
            background: hsla(210, 70%, 95%, 0.5);
        }

        .magnet-agent-repr-title {
            font-size: 9px;
            font-weight: 700;
            text-align: center;
            min-width: 14px;
        }

        .magnet-agent-a-box .magnet-agent-repr-title {
            color: hsl(0, 70%, 40%);
        }

        .magnet-agent-b-box .magnet-agent-repr-title {
            color: hsl(210, 70%, 40%);
        }

        .magnet-repr-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .magnet-repr-block {
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 7px;
            font-weight: 600;
            font-family: ui-monospace, monospace;
            border: 1.5px solid;
        }

        .magnet-beta-block {
            background: rgba(236, 72, 153, 0.2);
            border-color: #ec4899;
            color: #db2777;
        }

        .magnet-theta-block {
            background: rgba(6, 182, 212, 0.2);
            border-color: #06b6d4;
            color: #0891b2;
        }

        .magnet-transform-block {
            background: rgba(20, 184, 166, 0.2);
            border-color: #14b8a6;
            color: #0d9488;
        }

        .magnet-z-block {
            background: rgba(245, 158, 11, 0.2);
            border-color: #f59e0b;
            color: #d97706;
        }

        .magnet-delta-block {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
            color: #16a34a;
        }

        .magnet-partner-block {
            background: rgba(168, 85, 247, 0.2);
            border-color: #a855f7;
            color: #9333ea;
        }

        .magnet-noise-addition {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .magnet-interleaved-tokens,
        .magnet-block-noise,
        .magnet-noisy-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .magnet-interleaved-label {
            font-size: 10px;
            font-weight: 600;
            color: #334155;
            font-family: ui-monospace, monospace;
        }

        .magnet-interleaved-stack,
        .magnet-noise-stack {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .magnet-interleaved-cell {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid;
        }

        .magnet-interleaved-cell.agent-a {
            background: hsl(0, 70%, 40%);
            border-color: hsl(0, 70%, 55%);
        }

        .magnet-interleaved-cell.agent-b {
            background: hsl(210, 70%, 40%);
            border-color: hsl(210, 70%, 55%);
        }

        .magnet-interleaved-ellipsis {
            font-size: 12px;
            color: #64748b;
            text-align: center;
            line-height: 10px;
        }

        .magnet-noise-cell {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #94a3b8;
            background: #1e293b;
            overflow: hidden;
            position: relative;
        }

        .magnet-epsilon-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .magnet-noisy-stack {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .magnet-noisy-cell {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid;
            overflow: hidden;
            position: relative;
        }

        .magnet-noisy-cell.agent-a {
            background: hsl(0, 70%, 25%);
            border-color: hsl(0, 70%, 45%);
        }

        .magnet-noisy-cell.agent-b {
            background: hsl(210, 70%, 25%);
            border-color: hsl(210, 70%, 45%);
        }

        .magnet-noisy-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .magnet-noise-operator {
            font-size: 18px;
            font-weight: 700;
            color: #475569;
        }

        .magnet-prediction-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .magnet-prediction-stack {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .magnet-prediction-cell {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid;
        }

        .magnet-prediction-cell.agent-a {
            background: hsl(0, 70%, 50%);
            border-color: hsl(0, 70%, 65%);
            box-shadow: 0 0 6px hsla(0, 70%, 50%, 0.4);
        }

        .magnet-prediction-cell.agent-b {
            background: hsl(210, 70%, 50%);
            border-color: hsl(210, 70%, 65%);
            box-shadow: 0 0 6px hsla(210, 70%, 50%, 0.4);
        }

        .magnet-dfot {
            width: 90px;
            height: 120px;
            background: linear-gradient(180deg, #eff6ff, #dbeafe);
            border: 2px solid #3b82f6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            position: relative;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.2);
        }

        .magnet-dfot-title {
            font-size: 13px;
            font-weight: 700;
            color: #2563eb;
            margin-bottom: 2px;
        }

        .magnet-dfot-full-title {
            font-size: 7px;
            color: #475569;
            text-align: center;
            margin-bottom: 6px;
        }

        .magnet-dfot-layers {
            display: flex;
            flex-direction: column;
            gap: 3px;
            width: 100%;
            flex: 1;
        }

        .magnet-dfot-layer {
            height: 6px;
            background: rgba(59, 130, 246, 0.12);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .magnet-dfot-layer::after {
            content: '';
            position: absolute;
            left: -100%;
            top: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.5), transparent);
            animation: magnetDfotSweep 1.5s ease-in-out infinite;
        }

        .magnet-dfot-layer:nth-child(2)::after { animation-delay: 0.12s; }
        .magnet-dfot-layer:nth-child(3)::after { animation-delay: 0.24s; }
        .magnet-dfot-layer:nth-child(4)::after { animation-delay: 0.36s; }
        .magnet-dfot-layer:nth-child(5)::after { animation-delay: 0.48s; }
        .magnet-dfot-layer:nth-child(6)::after { animation-delay: 0.60s; }

        @keyframes magnetDfotSweep {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .magnet-dfot-loop {
            position: absolute;
            bottom: 5px;
            font-size: 9px;
            color: #475569;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .magnet-loop-icon {
            animation: magnetSpin 2s linear infinite;
        }

        @keyframes magnetSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .magnet-decoder-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .magnet-decoder-with-condition {
            display: flex;
            align-items: center;
            position: relative;
        }

        .magnet-decoder {
            position: relative;
            width: 75px;
            height: 100px;
        }

        .magnet-decoder-shape {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .magnet-decoder-shape svg {
            width: 100%;
            height: 100%;
        }

        .magnet-decoder-content {
            position: absolute;
            top: 50%;
            left: 55%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1;
        }

        .magnet-decoder-title {
            font-size: 11px;
            font-weight: 700;
            color: #16a34a;
            margin-bottom: 2px;
        }

        .magnet-decoder-subtitle {
            font-size: 8px;
            color: #475569;
        }

        .magnet-decoder-layers-inside {
            display: flex;
            flex-direction: column;
            gap: 3px;
            margin-top: 8px;
            width: 42px;
        }

        .magnet-decoder-layer-bar {
            height: 4px;
            background: rgba(34, 197, 94, 0.3);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .magnet-decoder-layer-bar::after {
            content: '';
            position: absolute;
            left: -100%;
            top: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.7), transparent);
            animation: magnetDecoderSweep 1.3s ease-in-out infinite;
        }

        .magnet-decoder-layer-bar:nth-child(2)::after { animation-delay: 0.2s; }
        .magnet-decoder-layer-bar:nth-child(3)::after { animation-delay: 0.4s; }

        @keyframes magnetDecoderSweep {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .magnet-legend-section {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 24px;
            margin-top: 16px;
            padding-top: 14px;
            border-top: 1px solid #cbd5e1;
        }

        .magnet-legend-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .magnet-legend-group-title {
            font-size: 11px;
            font-weight: 700;
            color: #334155;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .magnet-legend-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px 16px;
        }

        .magnet-legend-motion-token {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .magnet-legend-token-title {
            font-size: 11px;
            font-weight: 700;
            color: #334155;
        }

        .magnet-legend-token-content {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .magnet-agent-blocks-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .magnet-agent-block-large {
            width: 20px;
            height: 22px;
            border-radius: 4px;
            border: 2px solid;
        }

        .magnet-agent-block-large.agent-a {
            background: hsl(0, 70%, 40%);
            border-color: hsl(0, 70%, 55%);
        }

        .magnet-agent-block-large.agent-b {
            background: hsl(210, 70%, 40%);
            border-color: hsl(210, 70%, 55%);
        }

        .magnet-token-composition-legend {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            background: #ffffff;
            border-radius: 4px;
            border: 1px solid #94a3b8;
        }

        .magnet-token-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .magnet-token-label {
            font-size: 10px;
            color: #334155;
            width: 24px;
            text-align: right;
            font-family: ui-monospace, monospace;
            font-weight: 600;
        }

        .magnet-token-components {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .magnet-token-bracket {
            font-size: 14px;
            color: #64748b;
            font-weight: 300;
        }

        .magnet-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .magnet-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .magnet-legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .magnet-legend-text {
            font-size: 10px;
            color: #334155;
            font-weight: 500;
            white-space: nowrap;
        }

        .magnet-equation-bar {
            margin-top: 14px;
            padding: 10px 16px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            font-family: ui-monospace, monospace;
            font-size: 12px;
            color: #334155;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .magnet-eq-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .magnet-eq-z { color: #f59e0b; }
        .magnet-eq-delta { color: #22c55e; }
        .magnet-eq-partner { color: #a855f7; }
        .magnet-eq-beta { color: #ec4899; }
        .magnet-eq-theta { color: #06b6d4; }
        .magnet-eq-transform { color: #14b8a6; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="logo">
                <div class="logo-image">
                    <img src="assets/logo_v3.png" alt="MAGNeT Logo" />
                </div>
                <!-- <h1>MAGNeT</h1>
                <p>Multi-Agent Diffusion Forcing Transformer</p> -->
            
            </div>

            <nav class="nav-section">
                <h3>Navigation</h3>
                <a href="#teaser" class="nav-item active">
                    <!-- Play/Film icon for Teaser -->
                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4v16l13-8L7 4z"></path>
                    </svg>
                    <span>Teaser Video</span>
                </a>

                <a href="#abstract" class="nav-item">
                    <!-- Document/Text icon for Abstract -->
                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    <span>Abstract</span>
                </a>

               
                <a href="#method" class="nav-item">
                    <!-- Network/Architecture icon for Method -->
                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zm10 0a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zm10 0a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6M9 17h6M7 10v4m10-4v4"></path>
                    </svg>
                    <span>Method</span>
                </a>
                <a href="#denoising" class="nav-item">
                    <!-- Layers/Stacked icon for Denoising Schedule -->
                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                    </svg>
                    <span>Denoising Schedule</span>
                </a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Hero Section -->
            <section class="hero-section">
                <h2>Diffusion Forcing for Multi-Agent Interaction</h2>
                <br>
                <p class="hero-description">Vongani H. Maluleke<sup>*&sect;</sup>, Kie Horiuchi<sup>*&dagger;&sect;</sup>, Lea Wilken<sup>&sect;</sup>, Evonne Ng<sup>&Dagger;</sup>, Jitendra Malik<sup>&sect;</sup>, Angjoo Kanazawa<sup>&sect;</sup></p>
                <p class="hero-description"> Sony Group Corporation<sup>&dagger;</sup>, Meta<sup>&Dagger;</sup>, UC Berkeley<sup>&sect;</sup></p>

                <p class="hero-description" style="font-size: 1rem; color: #6b7280;"><sup>*</sup>Equal contribution</p>

                <div class="logo-links">
                  <div class="logo-link-wrapper">
                      <a href="#paper" class="logo-link">
                          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                          </svg>
                      </a>
                      <span class="logo-link-label">Paper</span>
                  </div>
                  <div class="logo-link-wrapper">
                      <a href="#code" class="logo-link">
                          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path>
                          </svg>
                      </a>
                      <span class="logo-link-label">Code Coming Soon</span>
                  </div>
              </div>
            </section>

            <!-- Teaser Video Section -->
            <section id="teaser" class="section">
                <div class="section-header">
                    <!-- <h3>Teaser Video</h3> -->
                </div>
                <div class="teaser-video">
                    <div class="video-player">
                        <video controls autoplay muted playsinline preload="metadata" poster="assets/teaser_thumbnail.jpg">
                            <!-- <source src="assets/MagNet_teaser.webm" type="video/webm"> -->
                            <source src="assets/MagNet_Teaser_121825.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="play-icon-large">
                            <div class="play-triangle"></div>
                        </div>
                    </div>
                    <p style="padding: 1.5rem 2rem; text-align: center; color: #4b5563; font-size: 1.0625rem; line-height: 1.7; margin: 0; background: #f9fafb; border-top: 1px solid #e5e7eb;">
                        MAGNeT: Multi-Agent Diffusion Forcing Transformer - A unified autoregressive diffusion framework for modeling and generating realistic motion of multiple interacting humans.
                    </p>
                </div>
            </section>

            <!-- Abstract Section -->
            <section id="abstract" class="section">
                <div class="section-header">
                    <h3>Abstract</h3>
                    <p>
                        Understanding and generating multi-person interactions is a fundamental challenge with broad implications for robotics and social computing. While humans naturally coordinate in groups, capturing this complexity in generative models remains an open problem. Current motion generation methods are specialized, handling only isolated tasks like dyadic reactions or partner prediction, and lack unified capabilities for comprehensive multi-agent motion generation. We introduce MAGNeT, Multi-Agent Diffusion Forcing Transformer, a unified autoregressive diffusion framework that bridges this gap. The model seamlessly handles interactions among multiple people and supports flexible sampling strategies for various tasks, including dyadic prediction, partner inpainting, and multi-agent motion generation. It can autoregressively generate hundreds of realistic motions for ultra-long sequences, capturing both synchronized activities (e.g., dancing, boxing) and diverse social interactions. Building on Diffusion Forcing, we introduce key modifications to enable effective modeling of inter-agent interactions. Our model performs on-par with specialized methods on dyadic interactions while naturally extending to polyadic scenarios with three or more peoplea capability enabled by our framework's scalable architecture.
                    </p>
                </div>
            </section>


            <!-- Method Video Section -->
            <section id="method" class="section">
                <!-- <div class="section-header">
                    <h3>Method Video</h3>
                    <p>Technical overview of the MAGNeT architecture and training process</p>
                </div>
            
                    <div class="video-player">
                        <video controls>
                            <source src="assets/3801_MagNet_Teaser.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="play-icon-large">
                            <div class="play-triangle"></div>
                        </div>
                    </div>
                </div> -->

                <!-- MAGNeT Pipeline Visualization -->
                <div class="section-header">
                    <h3>Method</h3>
                    <p>Technical overview of the MAGNeT architecture and training process</p>
                <div class="magnet-viz-container">
                    <div class="magnet-viz-header">
                        <h4 class="magnet-viz-title">MAGNeT Training Pipeline</h4>
                    </div>

                    <div class="magnet-main-viz">
                        <div class="magnet-pipeline">
                            <!-- Input Video with Motion Representation below -->
                            <div class="magnet-stage magnet-input-stage">
                                <div class="magnet-stage-label">Input Motion</div>
                                <div class="magnet-video-box">
                                    <video autoplay muted loop playsinline preload="metadata" poster="assets/method_videos/input_thumb.jpg">
                                        <source src="assets/method_videos/input.webm" type="video/webm">
                                        <source src="assets/method_videos/input.mp4" type="video/mp4">
                                    </video>
                                </div>
                                <!-- Motion Representation (rotated 90 degrees) -->
                                <div class="magnet-motion-repr-rotated">
                                    <div class="magnet-repr-label">Motion Repr.</div>
                                    <div class="magnet-motion-repr-container">
                                        <!-- Agent A -->
                                        <div class="magnet-agent-repr-box magnet-agent-a-box">
                                            <div class="magnet-agent-repr-title">A</div>
                                            <div class="magnet-repr-row">
                                                <div class="magnet-repr-block magnet-beta-block"></div>
                                                <div class="magnet-repr-block magnet-theta-block"></div>
                                                <div class="magnet-repr-block magnet-transform-block">T<sup>cr</sup></div>
                                                <div class="magnet-repr-block magnet-delta-block">T<sup>can</sup></div>
                                                <div class="magnet-repr-block magnet-partner-block">T<sup>AB</sup></div>
                                            </div>
                                        </div>
                                        <!-- Agent B -->
                                        <div class="magnet-agent-repr-box magnet-agent-b-box">
                                            <div class="magnet-agent-repr-title">B</div>
                                            <div class="magnet-repr-row">
                                                <div class="magnet-repr-block magnet-beta-block"></div>
                                                <div class="magnet-repr-block magnet-theta-block"></div>
                                                <div class="magnet-repr-block magnet-transform-block">T<sup>cr</sup></div>
                                                <div class="magnet-repr-block magnet-delta-block">T<sup>can</sup></div>
                                                <div class="magnet-repr-block magnet-partner-block">T<sup>BA</sup></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="magnet-arrow">
                                <div class="magnet-arrow-line"></div>
                                <div class="magnet-arrow-head"></div>
                            </div>

                            <!-- VQ-VAE Encoder with conditioning arrow -->
                            <div class="magnet-stage">
                                <div class="magnet-stage-label">Encoding</div>
                                <div class="magnet-vqvae-encoder-wrapper">
                                    <div class="magnet-encoder-with-condition">
                                        <!-- Input blocks -->
                                        <div class="magnet-vqvae-input-simple">
                                            <div class="magnet-input-title">x<sub>t</sub></div>
                                            <div class="magnet-repr-block magnet-theta-block"><sub>t</sub></div>
                                            <div class="magnet-repr-block magnet-transform-block">T<sup>canroot</sup></div>
                                        </div>
                                        
                                        <!-- Encoder trapezoid -->
                                        <div class="magnet-vqvae-encoder">
                                            <div class="magnet-encoder-shape">
                                                <svg viewBox="0 0 90 120" preserveAspectRatio="none">
                                                    <defs>
                                                        <linearGradient id="magnetEncoderGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                                                            <stop offset="0%" style="stop-color:#fef3c7"/>
                                                            <stop offset="100%" style="stop-color:#fde68a"/>
                                                        </linearGradient>
                                                    </defs>
                                                    <polygon 
                                                        points="0,0 0,120 90,100 90,20" 
                                                        fill="url(#magnetEncoderGrad)" 
                                                        stroke="#f59e0b" 
                                                        stroke-width="2"
                                                    />
                                                </svg>
                                            </div>
                                            <div class="magnet-encoder-content">
                                                <div class="magnet-encoder-title">VQ-VAE</div>
                                                <div class="magnet-encoder-subtitle">Encoder</div>
                                                <div class="magnet-encoder-layers-inside">
                                                    <div class="magnet-encoder-layer-bar"></div>
                                                    <div class="magnet-encoder-layer-bar"></div>
                                                    <div class="magnet-encoder-layer-bar"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Condition blocks -->
                                    <div class="magnet-condition-container">
                                        <div class="magnet-condition-arrow-up"></div>
                                        <div class="magnet-condition-simple">
                                            <div class="magnet-condition-title">c<sub>t</sub></div>
                                            <div class="magnet-condition-blocks-row">
                                                <div class="magnet-repr-block magnet-beta-block"></div>
                                                <div class="magnet-repr-block magnet-delta-block">T<sup>can</sup></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="magnet-arrow">
                                <div class="magnet-arrow-line"></div>
                                <div class="magnet-arrow-head"></div>
                            </div>

                            <!-- Noisy Tokens with interleaved visualization -->
                            <div class="magnet-stage">
                                <div class="magnet-stage-label">Noisy Tokens</div>
                                <div class="magnet-noise-addition">
                                    <!-- Interleaved motion tokens -->
                                    <div class="magnet-interleaved-tokens">
                                        <div class="magnet-interleaved-label">M<sub>0</sub></div>
                                        <div class="magnet-interleaved-stack">
                                            <div class="magnet-interleaved-cell agent-a"></div>
                                            <div class="magnet-interleaved-cell agent-b"></div>
                                            <div class="magnet-interleaved-cell agent-a"></div>
                                            <div class="magnet-interleaved-cell agent-b"></div>
                                            <div class="magnet-interleaved-ellipsis"></div>
                                            <div class="magnet-interleaved-cell agent-a"></div>
                                            <div class="magnet-interleaved-cell agent-b"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Plus sign -->
                                    <div class="magnet-noise-operator">+</div>
                                    
                                    <!-- Block noise -->
                                    <div class="magnet-block-noise">
                                        <div class="magnet-interleaved-label"></div>
                                        <div class="magnet-noise-stack" id="magnetEpsilonStack">
                                            <div class="magnet-noise-cell"><canvas class="magnet-epsilon-canvas"></canvas></div>
                                            <div class="magnet-noise-cell"><canvas class="magnet-epsilon-canvas"></canvas></div>
                                            <div class="magnet-noise-cell"><canvas class="magnet-epsilon-canvas"></canvas></div>
                                            <div class="magnet-noise-cell"><canvas class="magnet-epsilon-canvas"></canvas></div>
                                            <div class="magnet-interleaved-ellipsis"></div>
                                            <div class="magnet-noise-cell"><canvas class="magnet-epsilon-canvas"></canvas></div>
                                            <div class="magnet-noise-cell"><canvas class="magnet-epsilon-canvas"></canvas></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Equals sign -->
                                    <div class="magnet-noise-operator">=</div>
                                    
                                    <!-- Result: noisy tokens -->
                                    <div class="magnet-noisy-result">
                                        <div class="magnet-interleaved-label">M()</div>
                                        <div class="magnet-noisy-stack" id="magnetNoisyStack">
                                            <div class="magnet-noisy-cell agent-a"><canvas class="magnet-noisy-canvas"></canvas></div>
                                            <div class="magnet-noisy-cell agent-b"><canvas class="magnet-noisy-canvas"></canvas></div>
                                            <div class="magnet-noisy-cell agent-a"><canvas class="magnet-noisy-canvas"></canvas></div>
                                            <div class="magnet-noisy-cell agent-b"><canvas class="magnet-noisy-canvas"></canvas></div>
                                            <div class="magnet-interleaved-ellipsis"></div>
                                            <div class="magnet-noisy-cell agent-a"><canvas class="magnet-noisy-canvas"></canvas></div>
                                            <div class="magnet-noisy-cell agent-b"><canvas class="magnet-noisy-canvas"></canvas></div>
                                        </div>
                                    </div>
                                    
                                </div>
                            </div>

                            <div class="magnet-arrow">
                                <div class="magnet-arrow-line"></div>
                                <div class="magnet-arrow-head"></div>
                            </div>

                            <!-- DFoT -->
                            <div class="magnet-stage">
                                <div class="magnet-stage-label">Denoiser F<sub></sub></div>
                                <div class="magnet-dfot">
                                    <div class="magnet-dfot-title">DFoT</div>
                                    <div class="magnet-dfot-full-title">Diffusion Forcing Transformer</div>
                                    
                                    <div class="magnet-dfot-layers">
                                        <div class="magnet-dfot-layer"></div>
                                        <div class="magnet-dfot-layer"></div>
                                        <div class="magnet-dfot-layer"></div>
                                        <div class="magnet-dfot-layer"></div>
                                        <div class="magnet-dfot-layer"></div>
                                        <div class="magnet-dfot-layer"></div>
                                    </div>
                                    
                                    <div class="magnet-dfot-loop">
                                        <span class="magnet-loop-icon"></span>
                                        <span> N steps</span>
                                    </div>
                                </div>
                            </div>

                            <div class="magnet-arrow">
                                <div class="magnet-arrow-line"></div>
                                <div class="magnet-arrow-head"></div>
                            </div>

                            <!-- Output Section -->
                            <div class="magnet-stage">
                                <div class="magnet-stage-label">M<sub>0</sub></div>
                                <div class="magnet-prediction-result">
                                    <div class="magnet-prediction-stack">
                                        <div class="magnet-prediction-cell agent-a"></div>
                                        <div class="magnet-prediction-cell agent-b"></div>
                                        <div class="magnet-prediction-cell agent-a"></div>
                                        <div class="magnet-prediction-cell agent-b"></div>
                                        <div class="magnet-interleaved-ellipsis"></div>
                                        <div class="magnet-prediction-cell agent-a"></div>
                                        <div class="magnet-prediction-cell agent-b"></div>
                                    </div>
                                </div>
                            </div>

                            <div class="magnet-arrow">
                                <div class="magnet-arrow-line"></div>
                                <div class="magnet-arrow-head"></div>
                            </div>

                            <!-- Decoder with conditioning arrow -->
                            <div class="magnet-stage">
                                <div class="magnet-stage-label">Decoding</div>
                                <div class="magnet-decoder-wrapper">
                                    <div class="magnet-decoder-with-condition">
                                        <!-- Decoder trapezoid -->
                                        <div class="magnet-decoder">
                                            <div class="magnet-decoder-shape">
                                                <svg viewBox="0 0 90 120" preserveAspectRatio="none">
                                                    <defs>
                                                        <linearGradient id="magnetDecoderGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                                                            <stop offset="0%" style="stop-color:#dcfce7"/>
                                                            <stop offset="100%" style="stop-color:#bbf7d0"/>
                                                        </linearGradient>
                                                    </defs>
                                                    <polygon 
                                                        points="0,20 0,100 90,120 90,0" 
                                                        fill="url(#magnetDecoderGrad)" 
                                                        stroke="#22c55e" 
                                                        stroke-width="2"
                                                    />
                                                </svg>
                                            </div>
                                            <div class="magnet-decoder-content">
                                                <div class="magnet-decoder-title">VQ-VAE</div>
                                                <div class="magnet-decoder-subtitle">Decoder</div>
                                                <div class="magnet-decoder-layers-inside">
                                                    <div class="magnet-decoder-layer-bar"></div>
                                                    <div class="magnet-decoder-layer-bar"></div>
                                                    <div class="magnet-decoder-layer-bar"></div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Output blocks -->
                                        <div class="magnet-decoder-output-simple">
                                            <div class="magnet-output-title">X</div>
                                            <div class="magnet-repr-block magnet-theta-block"><sub>t</sub></div>
                                            <div class="magnet-repr-block magnet-transform-block">T<sup>canroot</sup></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Condition blocks -->
                                    <div class="magnet-condition-container">
                                        <div class="magnet-condition-arrow-up"></div>
                                        <div class="magnet-condition-simple">
                                            <div class="magnet-condition-title">c<sub>t</sub></div>
                                            <div class="magnet-condition-blocks-row">
                                                <div class="magnet-repr-block magnet-beta-block"></div>
                                                <div class="magnet-repr-block magnet-delta-block">T<sup>can</sup></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="magnet-arrow">
                                <div class="magnet-arrow-line"></div>
                                <div class="magnet-arrow-head"></div>
                            </div>

                            <!-- Output Video -->
                            <div class="magnet-stage">
                                <div class="magnet-stage-label">Reconstructed X</div>
                                <div class="magnet-video-box">
                                    <video autoplay muted loop playsinline preload="metadata" poster="assets/method_videos/output_thumb.jpg">
                                        <source src="assets/method_videos/output.webm" type="video/webm">
                                        <source src="assets/method_videos/output.mp4" type="video/mp4">
                                    </video>
                                </div>
                            </div>
                        </div>

                        <div class="magnet-legend-section">
                            <!-- Color Legend - Components -->
                            <div class="magnet-legend-group">
                                <div class="magnet-legend-group-title">Motion Components</div>
                                <div class="magnet-legend-grid">
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: rgba(236, 72, 153, 0.3); border: 2px solid #ec4899;"></div>
                                        <span class="magnet-legend-text">  body shape</span>
                                    </div>
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: rgba(6, 182, 212, 0.3); border: 2px solid #06b6d4;"></div>
                                        <span class="magnet-legend-text">  joint angles</span>
                                    </div>
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: rgba(20, 184, 166, 0.3); border: 2px solid #14b8a6;"></div>
                                        <span class="magnet-legend-text">T<sup>canroot</sup>  canonicalroot</span>
                                    </div>
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e;"></div>
                                        <span class="magnet-legend-text">T<sup>can</sup>  canonical delta</span>
                                    </div>
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: rgba(245, 158, 11, 0.3); border: 2px solid #f59e0b;"></div>
                                        <span class="magnet-legend-text">z  latent code</span>
                                    </div>
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: rgba(168, 85, 247, 0.3); border: 2px solid #a855f7;"></div>
                                        <span class="magnet-legend-text">T<sup>sp</sup>  selfpartner</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Agents -->
                            <div class="magnet-legend-group">
                                <div class="magnet-legend-group-title">Agents</div>
                                <div class="magnet-legend-grid">
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: hsl(0, 70%, 35%); border: 2px solid hsl(0, 70%, 55%);"></div>
                                        <span class="magnet-legend-text">Agent A</span>
                                    </div>
                                    <div class="magnet-legend-item">
                                        <div class="magnet-legend-color" style="background: hsl(210, 70%, 35%); border: 2px solid hsl(210, 70%, 55%);"></div>
                                        <span class="magnet-legend-text">Agent B</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Motion Token Definition -->
                            <div class="magnet-legend-group">
                                <div class="magnet-legend-group-title">Motion Token m<sub>i</sub><sup>p</sup></div>
                                <div class="magnet-legend-token-content">
                                    <div class="magnet-agent-blocks-left">
                                        <div class="magnet-agent-block-large agent-a"></div>
                                        <div class="magnet-agent-block-large agent-b"></div>
                                    </div>
                                    <div class="magnet-token-composition-legend">
                                        <div class="magnet-token-row">
                                            <div class="magnet-token-label">m<sup>A</sup></div>
                                            <div class="magnet-token-bracket">[</div>
                                            <div class="magnet-token-components">
                                                <div class="magnet-repr-block magnet-z-block">z<sup>A</sup></div>
                                                <div class="magnet-repr-block magnet-delta-block">T<sup>can</sup></div>
                                                <div class="magnet-repr-block magnet-partner-block">T<sup>AB</sup></div>
                                            </div>
                                            <div class="magnet-token-bracket">]</div>
                                        </div>
                                        <div class="magnet-token-row">
                                            <div class="magnet-token-label">m<sup>B</sup></div>
                                            <div class="magnet-token-bracket">[</div>
                                            <div class="magnet-token-components">
                                                <div class="magnet-repr-block magnet-z-block">z<sup>B</sup></div>
                                                <div class="magnet-repr-block magnet-delta-block">T<sup>can</sup></div>
                                                <div class="magnet-repr-block magnet-partner-block">T<sup>BA</sup></div>
                                            </div>
                                            <div class="magnet-token-bracket">]</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    
                </div>
                </div>
            </section>

            <!-- Denoising Schedule Section -->
            <section id="denoising" class="section">
                <div class="section-header">
                    <h3>Temporal Denoising Schedule</h3>
                    <p>Visualizing how tokens are denoised across time steps for different sampling strategies</p>
                </div>

                <div class="dfot-container">
                    <div class="dfot-wrapper">
                        <div class="dfot-tabs">
                            <button class="dfot-tab active" id="tabJoint">Joint Future Prediction</button>
                            <button class="dfot-tab" id="tabFull">Full Sequence Denoising</button>
                            <button class="dfot-tab" id="tabAgentic">Partner Inpainting</button>
                            <button class="dfot-tab" id="tabPartnerPred">Partner Prediction</button>
                            <button class="dfot-tab" id="tabAgenticSync">Agentic (Sync)</button>
                            <button class="dfot-tab" id="tabAgenticAsync">Agentic (Async)</button>
                            <button class="dfot-tab" id="tabInbetweening">Inbetweening</button>
                        </div>

                        <div class="dfot-description" id="dfotDescription">
                            <div class="dfot-description-title">
                                <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <span id="dfotDescTitle">Joint Future Prediction</span>
                            </div>
                            <p class="dfot-description-text" id="dfotDescText">
                                All agents' future motion is <span class="dfot-description-highlight">jointly generated</span> from a single distribution, ensuring coordinated predictions.
                                <br><br>
                                <span class="dfot-description-formula">P(A<sub>t:t+L</sub>, B<sub>t:t+L</sub> | A<sub>0:t1</sub>, B<sub>0:t1</sub>)</span>
                                <br><br>
                                Joint noise sampling preserves <span class="dfot-description-highlight">spatial and temporal correlations</span> and naturally extends to n  2 agents. Each token denoises progressively with causal dependencies.
                            </p>
                        </div>

                        <div class="dfot-controls">
                            <button class="dfot-btn dfot-btn-play" id="playBtn"> Pause</button>
                            <button class="dfot-btn dfot-btn-reset" id="resetBtn">Reset</button>
                            <div class="dfot-speed">
                                <label>Speed:</label>
                                <input type="range" id="speedSlider" min="0.5" max="3" step="0.5" value="1">
                                <span id="speedValue">1x</span>
                            </div>
                            <span class="dfot-frame">Frame: <span id="frameCount">0</span>/<span id="totalFrames">200</span></span>
                        </div>

                        <div class="dfot-timeline">
                            <label>Timeline:</label>
                            <input type="range" id="timelineSlider" min="0" max="199" step="1" value="0">
                        </div>

                        <div class="dfot-viz">
                            <div class="dfot-main">
                                <div class="dfot-yaxis-label">
                                    <span>Denoising Steps</span>
                                </div>
                                <div class="dfot-content">
                                    <div class="dfot-xaxis-title">Time</div>
                                    <div class="dfot-xaxis-labels" id="xAxisLabels"></div>
                                    <div class="dfot-grid">
                                        <div class="dfot-yaxis-numbers" id="yAxisNumbers"></div>
                                        <div class="dfot-rows" id="gridRows"></div>
                                    </div>
                                </div>
                            </div>

                            <div class="dfot-legend">
                                <div class="dfot-legend-item">
                                    <div class="dfot-legend-color" style="background: hsl(0, 70%, 30%); border: 2px solid hsl(0, 100%, 50%)"></div>
                                    <span class="dfot-legend-text">Agent A (clean)</span>
                                </div>
                                <div class="dfot-legend-item">
                                    <div class="dfot-legend-color" style="background: hsl(210, 70%, 30%); border: 2px solid hsl(210, 100%, 50%)"></div>
                                    <span class="dfot-legend-text">Agent B (clean)</span>
                                </div>
                                <div class="dfot-legend-item">
                                    <div class="dfot-legend-color dfot-noisy-legend" style="background: #1a1a1a; position: relative; overflow: hidden;">
                                        <canvas id="noisyLegendCanvas" width="16" height="16" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
                                    </div>
                                    <span class="dfot-legend-text">Noisy</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>


        </main>
    </div>

    <script>
    // ==========================================
    // DFoT Visualization
    // ==========================================
    const config = {
        timeSteps: 4,
        blockSize: 40,
        gap: 4,
        framesPerRow: 40
    };

    function getDenoiseSteps(mode) {
        if (mode === 'agenticAsync') {
            // Fully sequential: A1  B1  A2  B2  A3  B3
            // 6 tokens  2 steps each = 12 denoising steps
            return 12;
        }
        if (mode === 'agenticSync') {
            // Parallel: At each time step, A and B denoise together
            // 3 time steps  2 denoising steps each = 6 total steps
            return 6;
        }
        if (mode === 'partnerPred') {
            // 3 Agent A tokens, each takes 2 steps, fully sequential (no overlap)
            // A1: steps 0-1, A2: steps 2-3, A3: steps 4-5
            // B3 needs to appear after step 5, so we need row 6
            // So we need 7 rows (0-6)
            return 7;
        }
        return 5;
    }

    function getTotalFrames(mode) {
        return getDenoiseSteps(mode) * config.framesPerRow;
    }

    let state = {
        timeStep: 0,
        isPlaying: true,
        speed: 1,
        mode: 'joint'
    };

    let intervalId = null;

    // DOM elements
    const playBtn = document.getElementById('playBtn');
    const resetBtn = document.getElementById('resetBtn');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    const frameCount = document.getElementById('frameCount');
    const totalFramesEl = document.getElementById('totalFrames');
    const timelineSlider = document.getElementById('timelineSlider');
    const xAxisLabels = document.getElementById('xAxisLabels');
    const yAxisNumbers = document.getElementById('yAxisNumbers');
    const gridRows = document.getElementById('gridRows');
    const tabJoint = document.getElementById('tabJoint');
    const tabFull = document.getElementById('tabFull');
    const tabAgentic = document.getElementById('tabAgentic');
    const tabPartnerPred = document.getElementById('tabPartnerPred');
    const tabAgenticSync = document.getElementById('tabAgenticSync');
    const tabAgenticAsync = document.getElementById('tabAgenticAsync');
    const tabInbetweening = document.getElementById('tabInbetweening');

    function initXAxisLabels() {
        xAxisLabels.innerHTML = '';
        
        // Adjust margin for agentic modes to account for column wrapper padding/borders
        if (state.mode === 'agenticAsync' || state.mode === 'agenticSync') {
            xAxisLabels.style.marginLeft = '42px';
            xAxisLabels.style.gap = '8px';
        } else {
            xAxisLabels.style.marginLeft = '36px';
            xAxisLabels.style.gap = '0';
        }
        
        for (let t = 0; t < config.timeSteps; t++) {
            const group = document.createElement('div');
            group.className = 'dfot-xaxis-group';
            
            // For agentic modes, set proper spacing to match the column wrappers
            if (state.mode === 'agenticAsync' || state.mode === 'agenticSync') {
                group.style.width = '100px'; // 2 column wrappers (40+3+3+2 * 2 + gap)
                group.style.justifyContent = 'center';
            }
            
            group.innerHTML = `
                <div class="dfot-xaxis-label">A<sub>${t}</sub></div>
                <div class="dfot-xaxis-label">B<sub>${t}</sub></div>
            `;
            xAxisLabels.appendChild(group);
        }
    }

    function initYAxisNumbers() {
        const denoiseSteps = getDenoiseSteps(state.mode);
        yAxisNumbers.innerHTML = '';
        yAxisNumbers.style.display = 'flex';
        
        // Add top padding for agentic modes to align with column wrapper padding
        if (state.mode === 'agenticAsync' || state.mode === 'agenticSync') {
            yAxisNumbers.style.paddingTop = '5px';
        } else {
            yAxisNumbers.style.paddingTop = '0';
        }
        
        for (let d = 0; d < denoiseSteps; d++) {
            const num = document.createElement('div');
            num.className = 'dfot-yaxis-number';
            num.id = `yaxis-${d}`;
            num.innerHTML = `<span class="arrow" style="display:none"></span>${d}`;
            yAxisNumbers.appendChild(num);
        }
    }

    function initGrid() {
        const denoiseSteps = getDenoiseSteps(state.mode);
        gridRows.innerHTML = '';
        
        if (state.mode === 'agenticAsync' || state.mode === 'agenticSync') {
            const gridContainer = document.createElement('div');
            gridContainer.style.display = 'flex';
            gridContainer.style.gap = '8px';
            
            for (let t = 0; t < config.timeSteps; t++) {
                const timeGroup = document.createElement('div');
                timeGroup.style.display = 'flex';
                timeGroup.style.gap = '0';
                
                const colWrapperA = document.createElement('div');
                colWrapperA.className = 'dfot-agent-col-wrapper agent-a-wrapper';
                
                const colWrapperB = document.createElement('div');
                colWrapperB.className = 'dfot-agent-col-wrapper agent-b-wrapper';
                
                for (let d = 0; d < denoiseSteps; d++) {
                    const blockA = document.createElement('div');
                    blockA.className = 'dfot-block';
                    blockA.id = `block-${d}-${t}-A`;
                    const canvasA = document.createElement('canvas');
                    canvasA.width = config.blockSize;
                    canvasA.height = config.blockSize;
                    blockA.appendChild(canvasA);
                    colWrapperA.appendChild(blockA);
                    
                    const blockB = document.createElement('div');
                    blockB.className = 'dfot-block';
                    blockB.id = `block-${d}-${t}-B`;
                    const canvasB = document.createElement('canvas');
                    canvasB.width = config.blockSize;
                    canvasB.height = config.blockSize;
                    blockB.appendChild(canvasB);
                    colWrapperB.appendChild(blockB);
                }
                
                timeGroup.appendChild(colWrapperA);
                timeGroup.appendChild(colWrapperB);
                gridContainer.appendChild(timeGroup);
            }
            
            gridRows.appendChild(gridContainer);
            
            for (let d = 0; d < denoiseSteps; d++) {
                const row = document.createElement('div');
                row.className = 'dfot-row';
                row.id = `row-${d}`;
                row.style.display = 'none';
                gridRows.appendChild(row);
            }
        } else {
            for (let d = 0; d < denoiseSteps; d++) {
                const row = document.createElement('div');
                row.className = 'dfot-row';
                row.id = `row-${d}`;

                for (let t = 0; t < config.timeSteps; t++) {
                    const group = document.createElement('div');
                    group.className = 'dfot-time-group';

                    const blockA = document.createElement('div');
                    blockA.className = 'dfot-block';
                    blockA.id = `block-${d}-${t}-A`;
                    const canvasA = document.createElement('canvas');
                    canvasA.width = config.blockSize;
                    canvasA.height = config.blockSize;
                    blockA.appendChild(canvasA);
                    group.appendChild(blockA);

                    const blockB = document.createElement('div');
                    blockB.className = 'dfot-block';
                    blockB.id = `block-${d}-${t}-B`;
                    const canvasB = document.createElement('canvas');
                    canvasB.width = config.blockSize;
                    canvasB.height = config.blockSize;
                    blockB.appendChild(canvasB);
                    group.appendChild(blockB);

                    row.appendChild(group);
                }

                gridRows.appendChild(row);
            }
        }
    }

    // Noise intensity functions
    function getNoiseIntensityJoint(denoiseStep, timeIdx, timeStep) {
        if (timeIdx === 0) return 0;
        const tokenNumber = timeIdx - 1;
        const tokenDenoiseStartStep = tokenNumber;
        const denoiseStepsPerToken = 3;
        const framesPerRow = config.framesPerRow;
        const currentDenoiseRow = Math.floor(timeStep / framesPerRow);
        const rowStartFrame = denoiseStep * framesPerRow;
        const isRowActive = timeStep >= rowStartFrame && timeStep < rowStartFrame + framesPerRow;
        const rowProgress = isRowActive ? (timeStep - rowStartFrame) / framesPerRow : 0;

        let targetIntensity, prevIntensity;
        if (denoiseStep < tokenDenoiseStartStep) targetIntensity = 1.0;
        else if (denoiseStep < tokenDenoiseStartStep + denoiseStepsPerToken) {
            const stepsInto = denoiseStep - tokenDenoiseStartStep;
            targetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
        } else targetIntensity = 0;

        if (denoiseStep === 0) prevIntensity = 1.0;
        else if (denoiseStep - 1 < tokenDenoiseStartStep) prevIntensity = 1.0;
        else if (denoiseStep - 1 < tokenDenoiseStartStep + denoiseStepsPerToken) {
            const stepsInto = (denoiseStep - 1) - tokenDenoiseStartStep;
            prevIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
        } else prevIntensity = 0;

        if (denoiseStep > currentDenoiseRow) {
            if (currentDenoiseRow < tokenDenoiseStartStep) return 1.0;
            if (currentDenoiseRow < tokenDenoiseStartStep + denoiseStepsPerToken) {
                const stepsInto = currentDenoiseRow - tokenDenoiseStartStep;
                const rowPrevIntensity = stepsInto === 0 ? 1.0 : Math.max(0.0, 1.0 - (stepsInto / denoiseStepsPerToken));
                const rowTargetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
                return rowPrevIntensity + (rowTargetIntensity - rowPrevIntensity) * ((timeStep % framesPerRow) / framesPerRow);
            }
            return 0;
        }
        if (isRowActive) return prevIntensity + (targetIntensity - prevIntensity) * rowProgress;
        return targetIntensity;
    }

    function getNoiseIntensityFull(denoiseStep, timeIdx, timeStep) {
        if (timeIdx === 0) return 0;
        const denoiseStepsPerToken = 5;
        const framesPerRow = config.framesPerRow;
        const currentDenoiseRow = Math.floor(timeStep / framesPerRow);
        const rowStartFrame = denoiseStep * framesPerRow;
        const isRowActive = timeStep >= rowStartFrame && timeStep < rowStartFrame + framesPerRow;
        const rowProgress = isRowActive ? (timeStep - rowStartFrame) / framesPerRow : 0;

        let targetIntensity = denoiseStep < denoiseStepsPerToken ? Math.max(0.0, 1.0 - ((denoiseStep + 1) / denoiseStepsPerToken)) : 0;
        let prevIntensity = denoiseStep === 0 ? 1.0 : (denoiseStep - 1 < denoiseStepsPerToken ? Math.max(0.0, 1.0 - (denoiseStep / denoiseStepsPerToken)) : 0);

        if (denoiseStep > currentDenoiseRow) {
            if (currentDenoiseRow < denoiseStepsPerToken) {
                const rowPrevIntensity = currentDenoiseRow === 0 ? 1.0 : Math.max(0.0, 1.0 - (currentDenoiseRow / denoiseStepsPerToken));
                const rowTargetIntensity = Math.max(0.0, 1.0 - ((currentDenoiseRow + 1) / denoiseStepsPerToken));
                return rowPrevIntensity + (rowTargetIntensity - rowPrevIntensity) * ((timeStep % framesPerRow) / framesPerRow);
            }
            return 0;
        }
        if (isRowActive) return prevIntensity + (targetIntensity - prevIntensity) * rowProgress;
        return targetIntensity;
    }

    function getNoiseIntensityPartnerInpainting(denoiseStep, timeIdx, timeStep, agent) {
        if (timeIdx === 0) return 0;
        if (agent === 'A') return 0;
        return getNoiseIntensityFull(denoiseStep, timeIdx, timeStep);
    }

    // Calculate noise intensity for PARTNER PREDICTION mode
    // P(A_{t:L} | A_{0:t-1}, B_{0:t-1})
    // Both agents' past (t=0) is clean (conditioning)
    // Agent A's future (t>=1) denoises FULLY SEQUENTIALLY - each token completes before next starts
    // Agent B's future (t>=1) is EMPTY until corresponding A token is fully denoised, then appears clean
    // Returns: number for noise intensity, or 'empty' for empty/invisible blocks
    function getNoiseIntensityPartnerPrediction(denoiseStep, timeIdx, timeStep, agent) {
        // Context blocks (t=0) are always clean for both agents
        if (timeIdx === 0) return 0;

        const tokenNumber = timeIdx - 1; // 0, 1, 2 for t=1, t=2, t=3
        const denoiseStepsPerToken = 2;
        // Fully sequential: each token starts after previous completes
        const tokenDenoiseStartStep = tokenNumber * denoiseStepsPerToken; // 0, 2, 4
        
        // Agent A token is fully denoised after completing its denoising steps
        const aTokenFullyDenoisedAfterStep = tokenDenoiseStartStep + denoiseStepsPerToken - 1; // 1, 3, 5

        const framesPerRow = config.framesPerRow;
        const currentDenoiseRow = Math.floor(timeStep / framesPerRow);
        const rowStartFrame = denoiseStep * framesPerRow;
        const rowEndFrame = rowStartFrame + framesPerRow;
        const isRowActive = timeStep >= rowStartFrame && timeStep < rowEndFrame;
        const rowProgress = isRowActive ? (timeStep - rowStartFrame) / framesPerRow : 0;

        // Agent B: empty until A is done, then instantly clean ONLY in rows after A finishes
        if (agent === 'B') {
            // B appears clean starting from the row AFTER A finishes
            // A finishes at end of row aTokenFullyDenoisedAfterStep
            // So B should be clean in rows > aTokenFullyDenoisedAfterStep
            // And B should be empty in rows <= aTokenFullyDenoisedAfterStep
            
            // For this specific denoiseStep row, check if B should be visible
            if (denoiseStep <= aTokenFullyDenoisedAfterStep) {
                return 'empty'; // This row is before or during A's denoising - B is empty
            }
            
            // This row is after A finished - B is clean
            return 0;
        }

        // Agent A future (t>=1): FULLY SEQUENTIAL denoising
        // Target intensity for this token at this denoising step
        let targetIntensity;
        if (denoiseStep < tokenDenoiseStartStep) {
            targetIntensity = 1.0; // Not started yet
        } else if (denoiseStep < tokenDenoiseStartStep + denoiseStepsPerToken) {
            const stepsInto = denoiseStep - tokenDenoiseStartStep;
            targetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
        } else {
            targetIntensity = 0; // Fully denoised
        }

        // Previous intensity (what it was before this row)
        let prevIntensity;
        if (denoiseStep === 0) {
            prevIntensity = 1.0;
        } else if (denoiseStep - 1 < tokenDenoiseStartStep) {
            prevIntensity = 1.0;
        } else if (denoiseStep - 1 < tokenDenoiseStartStep + denoiseStepsPerToken) {
            const stepsInto = (denoiseStep - 1) - tokenDenoiseStartStep;
            prevIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
        } else {
            prevIntensity = 0;
        }

        // If this row hasn't been processed yet (waiting)
        if (denoiseStep > currentDenoiseRow) {
            // Calculate what this token's noise level is at the current row being processed
            let currentRowIntensity;
            if (currentDenoiseRow < tokenDenoiseStartStep) {
                currentRowIntensity = 1.0;
            } else if (currentDenoiseRow < tokenDenoiseStartStep + denoiseStepsPerToken) {
                const stepsInto = currentDenoiseRow - tokenDenoiseStartStep;
                const rowPrevIntensity = stepsInto === 0 ? 1.0 : Math.max(0.0, 1.0 - (stepsInto / denoiseStepsPerToken));
                const rowTargetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
                const currentRowProgress = (timeStep % framesPerRow) / framesPerRow;
                currentRowIntensity = rowPrevIntensity + (rowTargetIntensity - rowPrevIntensity) * currentRowProgress;
            } else {
                currentRowIntensity = 0;
            }
            return currentRowIntensity;
        }

        // If this row is currently being processed
        if (isRowActive) {
            return prevIntensity + (targetIntensity - prevIntensity) * rowProgress;
        }
        
        // If this row has already been processed
        return targetIntensity;
    }

    function getNoiseIntensityInbetweening(denoiseStep, timeIdx, timeStep, agent) {
        if (timeIdx === 0 || timeIdx === 3) return 0;
        return getNoiseIntensityFull(denoiseStep, timeIdx, timeStep);
    }

    // Calculate noise intensity for AGENTIC SYNC mode
    // Parallel: At each time step, A and B denoise together
    // Sequence: (A1,B1)  (A2,B2)  (A3,B3)
    // Each time step pair takes 2 denoising steps
    function getNoiseIntensityAgenticSync(denoiseStep, timeIdx, timeStep, agent) {
        // Context blocks (t=0) are always clean
        if (timeIdx === 0) return 0;

        const denoiseStepsPerTimeStep = 2;
        const tokenNumber = timeIdx - 1; // 0, 1, 2 for t=1, t=2, t=3
        
        // Both A and B at the same time step start together
        const tokenDenoiseStartStep = tokenNumber * denoiseStepsPerTimeStep;

        const framesPerRow = config.framesPerRow;
        const currentDenoiseRow = Math.floor(timeStep / framesPerRow);
        const rowStartFrame = denoiseStep * framesPerRow;
        const rowEndFrame = rowStartFrame + framesPerRow;
        const isRowActive = timeStep >= rowStartFrame && timeStep < rowEndFrame;
        const rowProgress = isRowActive ? (timeStep - rowStartFrame) / framesPerRow : 0;

        // Target intensity for this token at this denoising step
        let targetIntensity;
        if (denoiseStep < tokenDenoiseStartStep) {
            targetIntensity = 1.0; // Not started yet
        } else if (denoiseStep < tokenDenoiseStartStep + denoiseStepsPerTimeStep) {
            const stepsInto = denoiseStep - tokenDenoiseStartStep;
            targetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerTimeStep));
        } else {
            targetIntensity = 0; // Fully denoised
        }

        // Previous intensity (what it was before this row)
        let prevIntensity;
        if (denoiseStep === 0) {
            prevIntensity = 1.0;
        } else if (denoiseStep - 1 < tokenDenoiseStartStep) {
            prevIntensity = 1.0;
        } else if (denoiseStep - 1 < tokenDenoiseStartStep + denoiseStepsPerTimeStep) {
            const stepsInto = (denoiseStep - 1) - tokenDenoiseStartStep;
            prevIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerTimeStep));
        } else {
            prevIntensity = 0;
        }

        // If this row hasn't been processed yet (waiting)
        if (denoiseStep > currentDenoiseRow) {
            let currentRowIntensity;
            if (currentDenoiseRow < tokenDenoiseStartStep) {
                currentRowIntensity = 1.0;
            } else if (currentDenoiseRow < tokenDenoiseStartStep + denoiseStepsPerTimeStep) {
                const stepsInto = currentDenoiseRow - tokenDenoiseStartStep;
                const rowPrevIntensity = stepsInto === 0 ? 1.0 : Math.max(0.0, 1.0 - (stepsInto / denoiseStepsPerTimeStep));
                const rowTargetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerTimeStep));
                const currentRowProgress = (timeStep % framesPerRow) / framesPerRow;
                currentRowIntensity = rowPrevIntensity + (rowTargetIntensity - rowPrevIntensity) * currentRowProgress;
            } else {
                currentRowIntensity = 0;
            }
            return currentRowIntensity;
        }

        // If this row is currently being processed
        if (isRowActive) {
            return prevIntensity + (targetIntensity - prevIntensity) * rowProgress;
        }
        
        // If this row has already been processed
        return targetIntensity;
    }

    // Calculate noise intensity for AGENTIC ASYNC mode
    // Fully sequential denoising: A1  B1  A2  B2  A3  B3
    // Each token fully denoises (2 steps) before the next one starts
    // Sequence: A1(steps 0-1)  B1(steps 2-3)  A2(steps 4-5)  B2(steps 6-7)  A3(steps 8-9)  B3(steps 10-11)
    function getNoiseIntensityAgenticAsync(denoiseStep, timeIdx, timeStep, agent) {
        // Context blocks (t=0) are always clean
        if (timeIdx === 0) return 0;

        const denoiseStepsPerToken = 2;
        
        // Calculate which "slot" this agent/time combination is in the sequence
        // Sequence order: A1(0), B1(1), A2(2), B2(3), A3(4), B3(5)
        const tokenNumber = timeIdx - 1; // 0, 1, 2 for t=1, t=2, t=3
        const agentOffset = agent === 'A' ? 0 : 1;
        const sequenceSlot = tokenNumber * 2 + agentOffset; // 0-5
        
        // Fully sequential: each token starts after previous one completes
        const tokenDenoiseStartStep = sequenceSlot * denoiseStepsPerToken;

        const framesPerRow = config.framesPerRow;
        const currentDenoiseRow = Math.floor(timeStep / framesPerRow);
        const rowStartFrame = denoiseStep * framesPerRow;
        const rowEndFrame = rowStartFrame + framesPerRow;
        const isRowActive = timeStep >= rowStartFrame && timeStep < rowEndFrame;
        const rowProgress = isRowActive ? (timeStep - rowStartFrame) / framesPerRow : 0;

        // Target intensity for this token at this denoising step
        let targetIntensity;
        if (denoiseStep < tokenDenoiseStartStep) {
            targetIntensity = 1.0; // Not started yet
        } else if (denoiseStep < tokenDenoiseStartStep + denoiseStepsPerToken) {
            const stepsInto = denoiseStep - tokenDenoiseStartStep;
            targetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
        } else {
            targetIntensity = 0; // Fully denoised
        }

        // Previous intensity (what it was before this row)
        let prevIntensity;
        if (denoiseStep === 0) {
            prevIntensity = 1.0;
        } else if (denoiseStep - 1 < tokenDenoiseStartStep) {
            prevIntensity = 1.0;
        } else if (denoiseStep - 1 < tokenDenoiseStartStep + denoiseStepsPerToken) {
            const stepsInto = (denoiseStep - 1) - tokenDenoiseStartStep;
            prevIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
        } else {
            prevIntensity = 0;
        }

        // If this row hasn't been processed yet (waiting)
        if (denoiseStep > currentDenoiseRow) {
            // Calculate what this token's noise level is at the current row being processed
            let currentRowIntensity;
            if (currentDenoiseRow < tokenDenoiseStartStep) {
                currentRowIntensity = 1.0;
            } else if (currentDenoiseRow < tokenDenoiseStartStep + denoiseStepsPerToken) {
                const stepsInto = currentDenoiseRow - tokenDenoiseStartStep;
                const rowPrevIntensity = stepsInto === 0 ? 1.0 : Math.max(0.0, 1.0 - (stepsInto / denoiseStepsPerToken));
                const rowTargetIntensity = Math.max(0.0, 1.0 - ((stepsInto + 1) / denoiseStepsPerToken));
                const currentRowProgress = (timeStep % framesPerRow) / framesPerRow;
                currentRowIntensity = rowPrevIntensity + (rowTargetIntensity - rowPrevIntensity) * currentRowProgress;
            } else {
                currentRowIntensity = 0;
            }
            return currentRowIntensity;
        }

        // If this row is currently being processed
        if (isRowActive) {
            return prevIntensity + (targetIntensity - prevIntensity) * rowProgress;
        }
        
        // If this row has already been processed
        return targetIntensity;
    }

    function getNoiseIntensity(denoiseStep, timeIdx, timeStep, agent) {
        if (state.mode === 'joint') return getNoiseIntensityJoint(denoiseStep, timeIdx, timeStep);
        if (state.mode === 'full') return getNoiseIntensityFull(denoiseStep, timeIdx, timeStep);
        if (state.mode === 'agentic') return getNoiseIntensityPartnerInpainting(denoiseStep, timeIdx, timeStep, agent);
        if (state.mode === 'partnerPred') return getNoiseIntensityPartnerPrediction(denoiseStep, timeIdx, timeStep, agent);
        if (state.mode === 'agenticSync') return getNoiseIntensityAgenticSync(denoiseStep, timeIdx, timeStep, agent);
        if (state.mode === 'agenticAsync') return getNoiseIntensityAgenticAsync(denoiseStep, timeIdx, timeStep, agent);
        return getNoiseIntensityInbetweening(denoiseStep, timeIdx, timeStep, agent);
    }

    function drawNoise(canvas, intensity) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, config.blockSize, config.blockSize);
        if (intensity < 0.05) return;
        const pixelSize = 3;
        const cols = Math.ceil(config.blockSize / pixelSize);
        const rows = Math.ceil(config.blockSize / pixelSize);
        ctx.globalAlpha = intensity * 0.7;
        for (let i = 0; i < cols * rows; i++) {
            if (Math.random() < intensity) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8})`;
                ctx.fillRect((i % cols) * pixelSize, Math.floor(i / cols) * pixelSize, pixelSize, pixelSize);
            }
        }
        ctx.globalAlpha = 1;
    }

    function updateBlock(denoiseStep, timeIdx, agent, timeStep) {
        const block = document.getElementById(`block-${denoiseStep}-${timeIdx}-${agent}`);
        if (!block) return;
        const canvas = block.querySelector('canvas');
        const baseHue = agent === 'A' ? 0 : 210; // Red for A, Blue for B
        
        let isContext = false;
        if (state.mode === 'inbetweening') {
            isContext = (timeIdx === 0 || timeIdx === 3);
        } else if (state.mode === 'agentic') {
            isContext = (timeIdx === 0 || agent === 'A');
        } else if (state.mode === 'partnerPred') {
            // Partner Prediction: P(A_{t:L} | A_{0:t-1}, B_{0:t-1})
            // A0 and B0 are always context (clean)
            isContext = (timeIdx === 0);
        } else {
            isContext = (timeIdx === 0);
        }

        const noiseIntensity = isContext ? 0 : getNoiseIntensity(denoiseStep, timeIdx, timeStep, agent);

        if (isContext) {
            // Context blocks: more opaque with higher saturation
            block.style.backgroundColor = `hsl(${baseHue}, 100%, 35%)`;
            block.style.borderColor = `hsl(${baseHue}, 100%, 50%)`;
            block.style.opacity = '1';
            block.style.boxShadow = 'none';
            canvas.getContext('2d').clearRect(0, 0, config.blockSize, config.blockSize);
            return;
        }

        // Handle empty blocks (Partner Prediction - Agent B before A is done)
        if (noiseIntensity === 'empty') {
            block.style.backgroundColor = 'transparent';
            block.style.borderColor = '#334155';
            block.style.borderStyle = 'dashed';
            block.style.boxShadow = 'none';
            canvas.getContext('2d').clearRect(0, 0, config.blockSize, config.blockSize);
            return;
        }
        
        // Reset border style for non-empty blocks
        block.style.borderStyle = 'solid';

        if (noiseIntensity <= 0.05) {
            // Denoised blocks: same color as context blocks
            block.style.backgroundColor = `hsl(${baseHue}, 100%, 35%)`;
            block.style.borderColor = `hsl(${baseHue}, 100%, 50%)`;
            block.style.opacity = '1';
            block.style.boxShadow = 'none';
            canvas.getContext('2d').clearRect(0, 0, config.blockSize, config.blockSize);
            return;
        }

        const saturation = (1 - noiseIntensity) * 80;
        const lightness = 15 + (1 - noiseIntensity) * 25;
        block.style.backgroundColor = `hsl(${baseHue}, ${saturation}%, ${lightness}%)`;
        block.style.borderColor = `hsl(${baseHue}, ${Math.max(20, saturation)}%, 45%)`;
        block.style.boxShadow = 'none';
        drawNoise(canvas, noiseIntensity);
    }

    function update() {
        const denoiseSteps = getDenoiseSteps(state.mode);
        const totalFrames = getTotalFrames(state.mode);
        
        frameCount.textContent = state.timeStep;
        totalFramesEl.textContent = totalFrames;
        timelineSlider.value = state.timeStep;
        timelineSlider.max = totalFrames - 1;

        for (let d = 0; d < denoiseSteps; d++) {
            const num = document.getElementById(`yaxis-${d}`);
            if (!num) continue;
            const rowStartFrame = d * config.framesPerRow;
            const isActive = state.timeStep >= rowStartFrame && state.timeStep < rowStartFrame + config.framesPerRow;
            num.className = isActive ? 'dfot-yaxis-number active' : 'dfot-yaxis-number';
            num.querySelector('.arrow').style.display = isActive ? 'inline' : 'none';
        }

        for (let d = 0; d < denoiseSteps; d++) {
            const row = document.getElementById(`row-${d}`);
            const rowStartFrame = d * config.framesPerRow;
            const isActive = state.timeStep >= rowStartFrame && state.timeStep < rowStartFrame + config.framesPerRow;

            if (row && state.mode !== 'agenticAsync') {
                row.className = isActive ? 'dfot-row active' : 'dfot-row';
            }

            for (let t = 0; t < config.timeSteps; t++) {
                updateBlock(d, t, 'A', state.timeStep);
                updateBlock(d, t, 'B', state.timeStep);
                
                if (state.mode === 'agenticAsync' || state.mode === 'agenticSync') {
                    const blockA = document.getElementById(`block-${d}-${t}-A`);
                    const blockB = document.getElementById(`block-${d}-${t}-B`);
                    if (blockA) blockA.classList.toggle('active-row', isActive);
                    if (blockB) blockB.classList.toggle('active-row', isActive);
                }
            }
        }
    }

    function startAnimation() {
        if (intervalId) clearInterval(intervalId);
        intervalId = setInterval(() => {
            state.timeStep = (state.timeStep + 1) % getTotalFrames(state.mode);
            update();
        }, 50 / state.speed);
    }

    function stopAnimation() {
        if (intervalId) { clearInterval(intervalId); intervalId = null; }
    }

    // Mode descriptions for the denoising schedule
    const modeDescriptions = {
        joint: {
            title: 'Joint Future Prediction',
            text: `All agents' future motion is <span class="dfot-description-highlight">jointly generated</span> from a single distribution, ensuring coordinated predictions.
                <br><br>
                <span class="dfot-description-formula">P(A<sub>t:t+L</sub>, B<sub>t:t+L</sub> | A<sub>0:t1</sub>, B<sub>0:t1</sub>)</span>
                <br><br>
                Joint noise sampling preserves <span class="dfot-description-highlight">spatial and temporal correlations</span> and naturally extends to n  2 agents. Each token denoises progressively with causal dependencies.`
        },
        full: {
            title: 'Full Sequence Denoising',
            text: `All future tokens denoise <span class="dfot-description-highlight">simultaneously at the same rate</span>, treating the entire sequence as a single block.
                <br><br>
                <span class="dfot-description-formula">P(A<sub>1:L</sub>, B<sub>1:L</sub> | A<sub>0</sub>, B<sub>0</sub>)</span>
                <br><br>
                This approach applies <span class="dfot-description-highlight">uniform denoising</span> across all time steps, useful when temporal causality is less critical.`
        },
        agentic: {
            title: 'Partner In-painting',
            text: `Given the <span class="dfot-description-highlight">full sequence of Agent B</span>, the model reconstructs or completes the motion of Agent A.
                <br><br>
                <span class="dfot-description-formula">P(A<sub>0:L</sub> | B<sub>0:L</sub>)</span>
                <br><br>
                Agent B remains clean as <span class="dfot-description-highlight">conditioning context</span>, while Agent A's entire sequence denoises simultaneously.`
        },
        partnerPred: {
            title: 'Partner Prediction',
            text: `Forecast the <span class="dfot-description-highlight">future of a single agent</span> conditioned on both agents' past motion.
                <br><br>
                <span class="dfot-description-formula">P(A<sub>t:L</sub> | A<sub>0:t1</sub>, B<sub>0:t1</sub>)</span>
                <br><br>
                Agent A's future tokens denoise <span class="dfot-description-highlight">fully sequentially</span>, while Agent B tokens appear only after corresponding A tokens complete.`
        },
        agenticSync: {
            title: 'Agentic Sampling (Synchronous)',
            text: `A <span class="dfot-description-highlight">scalable approach</span> where agents act independently while reacting to one another.
                <br><br>
                <strong>Parallel Generation:</strong> All agents generate motion at time t <span class="dfot-description-highlight">simultaneously</span>.
                <br><br>
                <span class="dfot-description-formula">P(A<sub>t</sub> | A<sub>0:t1</sub>, B<sub>0:t1</sub>), &nbsp; P(B<sub>t</sub> | A<sub>0:t1</sub>, B<sub>0:t1</sub>)</span>
                <br><br>
                Both agents condition on the <span class="dfot-description-highlight">same past information</span> and denoise their next step together before moving to the next time step.`
        },
        agenticAsync: {
            title: 'Agentic Sampling (Asynchronous)',
            text: `A <span class="dfot-description-highlight">scalable approach</span> where agents act independently while reacting to one another.
                <br><br>
                <strong>Turn-Taking:</strong> Agents generate motion <span class="dfot-description-highlight">sequentially</span>, enabling reactive behaviors.
                <br><br>
                <span class="dfot-description-formula">P(A<sub>t</sub> | A<sub>0:t1</sub>, B<sub>0:t1</sub>), &nbsp; P(B<sub>t</sub> | A<sub>0:t</sub>, B<sub>0:t1</sub>)</span>
                <br><br>
                Agent B can react to Agent A's <span class="dfot-description-highlight">just-generated motion</span> at the same time step, enabling more responsive interactions.`
        },
        inbetweening: {
            title: 'In-Betweening',
            text: `Given an arbitrary set of <span class="dfot-description-highlight">predefined keyframes</span> for both agents, the goal is to generate continuous motion between them.
                <br><br>
                Let <span class="dfot-description-formula"></span> denote keyframes and <span class="dfot-description-formula"> = {t | t  }</span> be frames to generate.
                <br><br>
                <span class="dfot-description-formula">P(A<sub></sub>, B<sub></sub> | A<sub></sub>, B<sub></sub>)</span>
                <br><br>
                The model generates motions only for <span class="dfot-description-highlight">non-keyframe positions</span> while strictly adhering to the predefined keyframes.`
        }
    };

    function updateDescription(mode) {
        const descTitle = document.getElementById('dfotDescTitle');
        const descText = document.getElementById('dfotDescText');
        const desc = modeDescriptions[mode];
        if (desc && descTitle && descText) {
            descTitle.textContent = desc.title;
            descText.innerHTML = desc.text;
        }
    }

    function switchMode(newMode) {
        const oldMode = state.mode;
        const oldDenoiseSteps = getDenoiseSteps(state.mode);
        state.mode = newMode;
        const newDenoiseSteps = getDenoiseSteps(state.mode);
        
        tabJoint.classList.toggle('active', newMode === 'joint');
        tabFull.classList.toggle('active', newMode === 'full');
        tabAgentic.classList.toggle('active', newMode === 'agentic');
        tabPartnerPred.classList.toggle('active', newMode === 'partnerPred');
        tabAgenticSync.classList.toggle('active', newMode === 'agenticSync');
        tabAgenticAsync.classList.toggle('active', newMode === 'agenticAsync');
        tabInbetweening.classList.toggle('active', newMode === 'inbetweening');
        
        // Update description
        updateDescription(newMode);
        
        state.timeStep = 0;
        
        if (oldDenoiseSteps !== newDenoiseSteps || oldMode === 'agenticAsync' || newMode === 'agenticAsync' || oldMode === 'agenticSync' || newMode === 'agenticSync') {
            initXAxisLabels();
            initYAxisNumbers();
            initGrid();
        }
        
        update();
        if (state.isPlaying) startAnimation();
    }

    // Event handlers
    playBtn.addEventListener('click', () => {
        state.isPlaying = !state.isPlaying;
        playBtn.textContent = state.isPlaying ? ' Pause' : ' Play';
        playBtn.className = state.isPlaying ? 'dfot-btn dfot-btn-play' : 'dfot-btn dfot-btn-play paused';
        state.isPlaying ? startAnimation() : stopAnimation();
    });

    resetBtn.addEventListener('click', () => { state.timeStep = 0; update(); });

    speedSlider.addEventListener('input', (e) => {
        state.speed = parseFloat(e.target.value);
        speedValue.textContent = `${state.speed}x`;
        if (state.isPlaying) startAnimation();
    });

    timelineSlider.addEventListener('input', (e) => { state.timeStep = parseInt(e.target.value); update(); });

    tabJoint.addEventListener('click', () => { if (state.mode !== 'joint') switchMode('joint'); });
    tabFull.addEventListener('click', () => { if (state.mode !== 'full') switchMode('full'); });
    tabAgentic.addEventListener('click', () => { if (state.mode !== 'agentic') switchMode('agentic'); });
    tabPartnerPred.addEventListener('click', () => { if (state.mode !== 'partnerPred') switchMode('partnerPred'); });
    tabAgenticSync.addEventListener('click', () => { if (state.mode !== 'agenticSync') switchMode('agenticSync'); });
    tabAgenticAsync.addEventListener('click', () => { if (state.mode !== 'agenticAsync') switchMode('agenticAsync'); });
    tabInbetweening.addEventListener('click', () => { if (state.mode !== 'inbetweening') switchMode('inbetweening'); });

    function drawLegendNoise() {
        const canvas = document.getElementById('noisyLegendCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 16, 16);
        ctx.globalAlpha = 0.7;
        for (let x = 0; x < 16; x += 2) {
            for (let y = 0; y < 16; y += 2) {
                if (Math.random() < 0.5) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8})`;
                    ctx.fillRect(x, y, 2, 2);
                }
            }
        }
        ctx.globalAlpha = 1;
    }

    // Method sub-tabs removed - Denoising Schedule is now a separate navigable section

    // Smooth scroll for navigation
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
                this.classList.add('active');
            }
        });
    });

    // Update active nav item on scroll
    window.addEventListener('scroll', () => {
        const sections = document.querySelectorAll('.section');
        let current = '';
        sections.forEach(section => {
            if (window.pageYOffset >= section.offsetTop - 200) {
                current = section.getAttribute('id');
            }
        });
        document.querySelectorAll('.nav-item').forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('href') === `#${current}`) item.classList.add('active');
        });
    });

    // Initialize
    initXAxisLabels();
    initYAxisNumbers();
    initGrid();
    drawLegendNoise();
    update();
    startAnimation();


    // Update active nav item on scroll
    window.addEventListener('scroll', () => {
        const sections = document.querySelectorAll('.section');
        const navItems = document.querySelectorAll('.nav-item');
        
        let current = '';
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.clientHeight;
            if (window.pageYOffset >= sectionTop - 200) {
                current = section.getAttribute('id');
            }
        });

        navItems.forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('href') === `#${current}`) {
                item.classList.add('active');
            }
        });
    });

    // MAGNeT Pipeline Visualization - Draw animated white noise on epsilon canvases with varying intensity
    function drawMagnetEpsilonNoise() {
        const canvases = document.querySelectorAll('.magnet-epsilon-canvas');
        // Different noise levels for each epsilon cell (matching noisy tokens)
        const noiseLevels = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3];
        
        canvases.forEach((canvas, idx) => {
            const size = 20;
            canvas.width = size;
            canvas.height = size;
            
            const noiseIntensity = noiseLevels[idx] || 0.5;
            const ctx = canvas.getContext('2d');
            
            // Background darkness varies with noise level (more noise = lighter bg)
            const bgBrightness = Math.floor(30 + (1 - noiseIntensity) * 20);
            ctx.fillStyle = `rgb(${bgBrightness}, ${bgBrightness + 5}, ${bgBrightness + 15})`;
            ctx.fillRect(0, 0, size, size);
            
            const pixelSize = 2;
            for (let x = 0; x < size; x += pixelSize) {
                for (let y = 0; y < size; y += pixelSize) {
                    if (Math.random() < noiseIntensity) {
                        const brightness = Math.random();
                        // Higher noise levels get brighter pixels
                        const alpha = brightness * (0.5 + noiseIntensity * 0.5);
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.fillRect(x, y, pixelSize, pixelSize);
                    }
                }
            }
        });
    }

    // Draw animated noisy M() canvases with varying intensity
    function drawMagnetNoisyCanvases() {
        const canvases = document.querySelectorAll('.magnet-noisy-canvas');
        // Decreasing noise levels (earlier tokens noisier, later tokens cleaner)
        const noiseLevels = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3];
        
        canvases.forEach((canvas, idx) => {
            const size = 20;
            canvas.width = size;
            canvas.height = size;
            
            const noiseIntensity = noiseLevels[idx] || 0.5;
            const ctx = canvas.getContext('2d');
            
            const pixelSize = 2;
            for (let x = 0; x < size; x += pixelSize) {
                for (let y = 0; y < size; y += pixelSize) {
                    if (Math.random() < noiseIntensity) {
                        const brightness = Math.random();
                        // Higher noise levels get brighter pixels
                        const alpha = brightness * (0.5 + noiseIntensity * 0.5);
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.fillRect(x, y, pixelSize, pixelSize);
                    }
                }
            }
        });
    }

    // Animate noise at ~12fps for a nice flickering effect
    let magnetNoiseAnimationId = null;
    let magnetLastNoiseTime = 0;
    const magnetNoiseInterval = 83; // ~12fps
    
    function animateMagnetNoise(time) {
        if (time - magnetLastNoiseTime > magnetNoiseInterval) {
            drawMagnetEpsilonNoise();
            drawMagnetNoisyCanvases();
            magnetLastNoiseTime = time;
        }
        magnetNoiseAnimationId = requestAnimationFrame(animateMagnetNoise);
    }

    // Initialize MAGNeT visualization when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            drawMagnetEpsilonNoise();
            drawMagnetNoisyCanvases();
            animateMagnetNoise(0);
        });
    } else {
        drawMagnetEpsilonNoise();
        drawMagnetNoisyCanvases();
        animateMagnetNoise(0);
    }
    </script>
</body>
</html>